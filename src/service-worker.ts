/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;
const CACHE_NAME = 'paseos-v2';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.jpg'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'imagesjpg',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.js'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'scripts',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.xz'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'visual',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.html'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'Hypertext',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.mp3'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'Audios',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.css'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'Styles',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// Cache all files in the public directory
registerRoute(
  // Match all files in the public directory
  ({ request }) => request.url.startsWith(self.location.origin + '/public/applications/'),
  // Use CacheFirst strategy to cache files and serve them from cache if available
  new CacheFirst({
    cacheName: 'PublicFiles',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used files are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});


self.addEventListener('install', event => {
  console.log('Service Worker instalado');
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => {
      console.log('Caché abierta correctamente');
      return cache.addAll([
        // root
        '/',
        '/index.html',
        '/favicon.ico',
        '/manifest.json',
        '/logo192.png',
        '/logo512.png',
        // application assets
        '/assets/imagenes/logo-quellaveco.png',
        '/assets/imagenes/logo-eduverso.png',
        '/assets/imagenes/logo-eduverso-blanco.png',
        '/applications/images/advertencia.png',
        '/applications/images/click-izquierdo.png',
        '/applications/images/derecho.png',
        '/applications/images/paso1.png',
        '/applications/images/paso2.png',
        '/applications/images/paso3.png',
        '/applications/images/rueda.png',
        '/applications/images/tecla.png',
        '/applications/styles.css',
        '/applications/audios/area-1000-parte-a.mp3',
        '/applications/audios/area-1000-parte-b.mp3',
        '/applications/audios/area-2000-faja.mp3',
        '/applications/audios/area-2000.mp3',
        '/applications/audios/area-3000-parte-a.mp3',
        '/applications/audios/area-3000-parte-b.mp3',
        '/applications/audios/area-3000-parte-c.mp3',
        '/applications/audios/area-3300-1.mp3',
        '/applications/audios/area-3300.mp3',
        '/applications/audios/area-4000-parte-a.mp3',
        '/applications/audios/area-4000-parte-b.mp3',
        '/applications/audios/area-4000-parte-c.mp3',
        '/applications/audios/area-4000-parte-d.mp3',
        '/applications/audios/area-4000-parte-e.mp3',
        '/applications/audios/area-4000.mp3',
        '/applications/audios/area-5800.mp3',
        '/applications/audios/bienvenido-2.mp3',
        '/applications/audios/bienvenido-completo.mp3',
        '/applications/audios/bienvenido.mp3',
      
                // Aislamiento y bloqueo
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.html',
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.css',
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.js',
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.bin.xz',
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.bin',
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.blend',
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.gltf',
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.gltf.xz',
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.v3d.js',
                '/applications/Aislamiento_y_bloqueo/Aislamiento_y_bloqueo.visual_logic.js',
                 // Espacios_confinados_v01
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.html',
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.css',
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.js',
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.bin.xz',
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.bin',
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.blend',
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.gltf',
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.gltf.xz',
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.v3d.js',
                 '/applications/Espacios_confinados_v01/Espacios_confinados_v01.visual_logic.js',
                   // Trabajos_en_altura
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.html',
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.css',
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.js',
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.bin.xz',
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.bin',
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.blend',
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.gltf',
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.gltf.xz',
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.v3d.js',
                   '/applications/Trabajos_en_altura/Trabajos_en_altura.visual_logic.js',
                    // Trabajos_en_caliente
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.html',
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.css',
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.js',
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.bin.xz',
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.bin',
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.blend',
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.gltf',
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.gltf.xz',
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.v3d.js',
                    '/applications/Trabajos_en_caliente/Trabajos_en_caliente.visual_logic.js',
                
      ]);
    }).catch(error => {
      console.error('Error al abrir la caché:', error);
    })
  );
});

self.addEventListener('activate', event => {
  console.log('Service Worker activado');
  event.waitUntil(
    caches.keys().then(cacheNames => {
      // Elimina las cachés antiguas (excepto la caché actual)
      return Promise.all(
        cacheNames.filter(cacheName => {
          return cacheName !== CACHE_NAME;
        }).map(cacheName => {
          return caches.delete(cacheName);
        })
      );
    })
  );
});

self.addEventListener('fetch', event => {
  console.log('Solicitud fetch interceptada:', event.request.url);
  event.respondWith(handleFetch(event.request));
});

async function handleFetch(request:any) {
  try {
    // Intenta obtener la respuesta desde la caché
    const cachedResponse = await caches.match(request);

    // Si la respuesta está en caché, devuélvela
    if (cachedResponse) {
      console.log('Recurso encontrado en caché:', request.url);
      return cachedResponse;
    }

    // Si la respuesta no está en caché, haz la solicitud a la red
    const networkResponse = await fetch(request);

    // Abre el caché y almacena la respuesta de la red para futuras solicitudes
    const cache = await caches.open(CACHE_NAME);
    cache.put(request, networkResponse.clone());
    console.log('Recurso no encontrado en caché, solicitando a la red:', request.url);
    // Devuelve la respuesta de la red
    return networkResponse;
  } catch (error) {
    // Si hay un error al recuperar recursos, puedes manejarlo aquí
    console.error('Error en la solicitud:', error);
    // Devuelve una respuesta predeterminada o una página de error personalizada si es necesario
    return new Response('Error: Recurso no disponible', { status: 500, statusText: 'Internal Server Error' });
  }
}
